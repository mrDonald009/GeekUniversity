"""
Задание 1.
Реализуйте кодирование строки "по Хаффману".
У вас два пути:
1) тема идет тяжело? тогда вы можете, опираясь на пример с урока, сделать свою версию алгоритма
Разрешается и приветствуется изменение имен переменных, выбор других коллекций, различные изменения
и оптимизации.
КОПИПАСТ ПРИМЕРА ПРИНИМАТЬСЯ НЕ БУДЕТ!
2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например, через ООП или предложить иной подход к решению.

ВНИМАНИЕ: примеры заданий будут размещены в последний день сдачи.
Но постарайтесь обойтись без них.
"""
from collections import deque

def tree_haffman(stroka):                               # Функция строящая дерево

    haffman = {}                                        # Создаю словарь


    for el in list(stroka):
        haffman.setdefault(el, list(stroka).count(el))  # Из списка (list(beep boop beer!)) в словарь haffman добавляю пару
                                                        # ключ, значение, где ключ это символ, а значение - кол-во символа
                                                        # встречающегося в этом списке

    list_haffman = list(haffman.items())                # Создаю список из элементов (ключ, значение) словаря haffman
    list_haffman.sort(key=lambda i: i[1])               # Сортирую список по первому индексу каждого элемента (по возрастанию)
    deque_haffman = deque(list_haffman)                 # Создаю очередь из отсортированного списка

    if len(deque_haffman) != 1:                         # Проверяю, что кол-во элементов в очереди не равно одному
        while len(deque_haffman) > 1:                   # Создаю цикл, который будет выполняться пока кол-во элементов
                                                        # больше одного.

            sum_frequency = deque_haffman[0][1] + deque_haffman[1][1] # Создаю переменную, которая будет хранить сумму
                                                                      # элементов с индексом № 1, первых двух элементов в
                                                                      # из очереди

            dict_slice = {                               # Создаю словарь, который будет хранить два элемента
                0: deque_haffman.popleft()[0],           # (первые два) из очереди,
                1: deque_haffman.popleft()[0]            # одновременно удаляя их из deque_haffman.
            }

            for i, el in enumerate(deque_haffman):       # Создаю цикл из последовательности индекса и значения индекса очереди
                if sum_frequency > el[1]:                # Условие позволяющее сортировать начало очереди
                    continue
                else:
                    deque_haffman.insert(i, (dict_slice, sum_frequency))   # Вставка элемента(из словаря и суммы частот) в очередь
                                                                           # на позицию элемента, чей элемент с индексом [1]
                                                                           # меньше или равен сумме частот
                    break
            else:
                deque_haffman.append((dict_slice, sum_frequency))          # Если у всех элементов из очереди(deque_haffman)
                                                                           # значение индекска №1 меньше суммы частоты
                                                                           # то элемент добавляю в конец списка

        else:                                                              # Как только останется последний элемент в
                                                                           # очереди выполнится следующее условие:
                                                                           # В переменную
            sum_frequency = deque_haffman[0][1]
            dict_slice = {                                                 # В словарь dict_slice сохраняю первый
                0: deque_haffman.popleft()[0],                             # элемент deque_haffman и удаляю из очереди
                1: None
            }
            deque_haffman.append((dict_slice, sum_frequency))              # Добавлю словарь в очередь и верну

        return deque_haffman[0][0]                                         # полученный результат



code_tree = {}                                                             # Создаю словарь для хранения кода

def branch_haffman(leg, way=''):                                         # Создаю функцию, которая из полученного
                                                                         # словаря будет рекурсивно собирать элементы

    if not isinstance(leg, dict):                                        # Первая часть рекурсии, задаю базовое условие,
        code_tree[leg] = way                                             # что элемент является символом, а не словарем

    else:
        branch_haffman(leg[0], way=f'{way}0')                            # Второая часть рекурсии, иду дальше по первому
        branch_haffman(leg[1], way=f'{way}1')                            # и второму значению словаря

stroka = 'beep boop beer!'

branch_haffman(tree_haffman(stroka))                                     # Вызываю функцию и передаю в нее значение от
                                                                         # из первой функции

for el in stroka:                                                        # Вывожу код для каждого символа
    print(code_tree[el], end=' ')
print()

